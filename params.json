{"name":"DynamicObject","tagline":"Lightweight data modeling for Java, powered by Clojure.","body":"[![Build Status](http://img.shields.io/travis/rschmitt/dynamic-object.svg)](https://travis-ci.org/rschmitt/dynamic-object)\r\n[![Maven Central](https://img.shields.io/maven-central/v/com.github.rschmitt/dynamic-object.svg)](https://maven-badges.herokuapp.com/maven-central/com.github.rschmitt/dynamic-object)\r\n[![License](https://img.shields.io/github/license/rschmitt/dynamic-object.svg)](https://creativecommons.org/about/cc0)\r\n# DynamicObject\r\n\r\nDynamicObject is a library that makes Clojure's powerful data modeling capabilities available to Java developers in an idiomatic way with minimal boilerplate. It reflects the belief that [values](http://www.infoq.com/presentations/Value-Values) should be immutable, cheap to specify, powerful to work with, and easy to convey to other processes.\r\n\r\nGet it from [Maven](http://search.maven.org/#artifactdetails|com.github.rschmitt|dynamic-object|1.4.2|jar):\r\n\r\n`com.github.rschmitt:dynamic-object:1.4.2`\r\n\r\n## The Problem\r\n\r\nThe Java programming language is flawlessly incompetent at representing data. Classes are the main programming language construct in Java, and the entire point of classes is to *combine* data and code such that data is \"encapsulated\" and can only be accessed through an operational interface, if at all. Creating a class that does nothing but hold data requires the creation of *pages* of boilerplate--getters, setters, constructors, `clone`, `equals`, `hashCode`, `toString`, and so on. Not only is this labor-intensive to do by hand, it's surprisingly error prone: copy and paste can result in getters/setters touching the wrong fields, methods like `equals` can be overlooked when a new field is added, pervasive unmoderated mutability is the default, the `equals`/`hashCode`/`compareTo` contract is far more subtle than most realize, implementation inheritance is almost intractably complex, and concurrency and serialization have to be figured out from scratch.\r\n\r\nThere have been countless attempts to address various subsets (or supersets) of these problems: IDE code generation, compile-time code generation, object mapping, test case generators, annotation processors, public fields, and so on. These tools are usually helpful in the right context, but they're really only workarounds for a fundamentally broken approach to working with data. Instead of trying to fix a broken approach, why not switch to a better one altogether?\r\n\r\nAnyone who has used Clojure's [data structures](http://clojure.org/data_structures) knows that there is a night-and-day difference between the Java and Clojure approaches to modeling data, and that Clojure's approach yields dramatically more leverage. One reason for Clojure's flexibility and power in working with data is its philosophy that *data belongs in maps*. Immutable persistent maps can be safely shared, compose well, can be sent to other programs (serialized and deserialized), are expressive enough to model almost anything, and can be generically processed by a collections library, which makes for excellent code reuse. Unfortunately, Clojure is radically different from what most developers are familiar with, in both superficial and profound ways. As a consequence, Clojure adoption is usually an uphill battle at best, and outright impossible at worst. But is it possible to get the benefits of Clojure without writing a line of Clojure code?\r\n\r\nBecause Clojure targets the JVM, it is possible for Java shops to use Clojure data without actually writing any Clojure code. However, there is a significant impedance mismatch between the two languages, and trying to call Clojure directly from Java results in a number of ergonomic problems, such as loss of type information, pervasive downcasting, and a Java API that is largely internal and undocumented. The goal of DynamicObject is to bridge the gap between the two languages and retain the advantages of both.\r\n\r\n## A Simple Example\r\n\r\nConsider a Clojure map that describes an album:\r\n\r\n```clojure\r\n{:artist \"Meshuggah\", :album \"Chaosphere\", :tracks 8, :year 1998}\r\n```\r\n\r\nGetting access to this data from Java is kind of a mess if you go directly through the Clojure runtime. It might look something like this:\r\n\r\n```java\r\nString edn = \"{:artist \\\"Meshuggah\\\", :album \\\"Chaosphere\\\", :tracks 8, :year 1998}\";\r\nMap albumDescription = (Map) Clojure.var(\"clojure.edn/read-string\").invoke(edn);\r\nString album = (String) albumDescription.get(Clojure.read(\":album\"));\r\n```\r\n\r\nThis is where DynamicObject comes in. The first thing to do is to create an `Album` type:\r\n\r\n```java\r\npublic interface Album extends DynamicObject<Album> {\r\n  @Key(\":artist\") String getArtist();\r\n  @Key(\":album\")  String getAlbum();\r\n  @Key(\":tracks\") int getTracks();\r\n  @Key(\":year\")   int getYear();\r\n\r\n  @Key(\":artist\") Album withArtist(String artist);\r\n  @Key(\":album\")  Album withAlbum(String album);\r\n  @Key(\":tracks\") Album withTracks(int tracks);\r\n  @Key(\":year\")   Album withYear(int year);\r\n}\r\n```\r\n\r\nThe purpose of this type is not to create a class that laboriously defines operations on data, but rather to establish a *schema* that tells DynamicObject which types are associated with each key. With DynamicObject, the above deserialization example looks like this:\r\n\r\n```java\r\nString edn = \"{:artist \\\"Meshuggah\\\", :album \\\"Chaosphere\\\", :tracks 8, :year 1998}\";\r\nAlbum album = DynamicObject.deserialize(edn, Album.class);\r\nString artist = album.getArtist();\r\nassertEquals(\"Meshuggah\", artist);\r\n```\r\n\r\nDynamicObjects can also be constructed in-memory through the use of builder methods (prefixed with `with-` in the above schema).\r\n\r\n```java\r\nAlbum album = DynamicObject.newInstance(Album.class)\r\n                           .withArtist(\"Meshuggah\")\r\n                           .withAlbum(\"Chaosphere\")\r\n                           .withTracks(8)\r\n                           .withYear(1998);\r\nalbum.prettyPrint();\r\n// {:year 1998, :tracks 8, :album \"Chaosphere\", :artist \"Meshuggah\"}\r\n```\r\n\r\n## Features\r\n\r\n* **Serialization.** Thanks to Clojure and the Edn data language, serialization is simple, reliable, extensible, and language-agnostic.\r\n* ![NEW](http://leaguecraft.com/images/core/theme-v4/icons/new-icon.png) **Binary serialization.** In addition to the human-readable Edn format, DynamicObject now offers full support for [Fressian](https://github.com/Datomic/fressian/wiki/Rationale), a self-describing, high-performance, language-independent binary data encoding.\r\n* **Immutability.** Because `DynamicObjects` are built out of [Clojure's data structures](http://clojure.org/data_structures), they are not just immutable and thread-safe, but also [persistent](http://en.wikipedia.org/wiki/Persistent_data_structure), which makes copying and modification cheap.\r\n* **Composability.** DynamicObjects compose correctly. Different types can be aggregated without losing serializability, equality semantics, or any of the other benefits of Clojure data. DynamicObjects even support structural recursion, such as this [example](https://github.com/rschmitt/dynamic-object/blob/master/src/test/java/com/github/rschmitt/dynamicobject/RecursionTest.java) of a linked list implemented as a DynamicObject.\r\n* **Schema validation.** DynamicObject offers basic schema validation Ã  la carte. The `validate` method will verify that all of an instance's fields are of the correct type, and that any fields annotated with `@Required` are not null. Additionally, validation can be extended by the end user in order to validate arbitrary constraints.\r\n* **Clojure metadata.** Fields that are annotated with `@Meta` are stored internally as [Clojure metadata](http://clojure.org/metadata). These fields allow data to be annotated in arbitrary ways without actually changing the structure or semantics of the data itself. Metadata does not affect equality: two objects that differ only in metadata are considered equal.\r\n* **User-defined methods.** A DynamicObject can declare methods just like an ordinary class can. This is particularly helpful for supporting high-quality code completion.\r\n* **Copy-on-write support.** DynamicObject supports builder methods, which are similar to Lombok [`@Wither`](http://projectlombok.org/features/experimental/Wither.html) methods: they are used to create a clone of an instance that has a single field changed. They are backed by Clojure's `assoc` function, which is extremely performant, thanks to Clojure's sophisticated immutable data structures.\r\n* **Easy to work with.** The DynamicObject API has a very small surface area, and using DynamicObject productively does not require any new tools: there is no Vim plugin, no Emacs minor mode, no Eclipse update site, no Gradle plugin, no special test runner. DynamicObject works for you, not the other way around.\r\n* ![NEW](http://leaguecraft.com/images/core/theme-v4/icons/new-icon.png) **Seamless Clojure interop.** DynamicObjects implement all of Clojure's map abstractions, such as `IPersistentMap`. This means that DynamicObjects have excellent ergonomics in both languages: the same DynamicObject instance looks and works like a Clojure map or record from Clojure code, and like an immutable POJO from Java code. Advanced functions from Clojure's collections library, such as `update-in` and `diff`, work exactly as expected.\r\n\r\n## Some More Examples\r\n\r\n### Creating DynamicObject types\r\n\r\nA DynamicObject type is a Java interface. The simplest possible DynamicObject type is this:\r\n\r\n```java\r\npublic interface Empty extends DynamicObject<Empty> {}\r\n```\r\n\r\nAlthough this type doesn't declare any particular fields, it is still usable as a map. For example:\r\n\r\n```java\r\nEmpty empty = DynamicObject.deserialize(\"{144 233}\", Empty.class);\r\n\r\nassertTrue(empty instanceof Map);\r\nassertEquals(Long.valueOf(233), empty.get(144));\r\nassertEquals(1, empty.size());\r\n```\r\n\r\nIn addition to the interface itself, it is strongly recommended that reader tags be created for each DynamicObject type that will be serialized. Otherwise, serialized DynamicObjects look indistinguishable from regular maps, and the full type information cannot be recovered without some additional out-of-band information (such as the second argument to `deserialize`).\r\n\r\n```java\r\npublic interface T1 extends DynamicObject<T1> {}\r\npublic interface T2 extends DynamicObject<T2> {}\r\n\r\nDynamicObject.registerTag(T1.class, \"T1\");\r\nDynamicObject.registerTag(T2.class, \"T2\");\r\n\r\n// Note the lack of type hints given to deserialize:\r\nassertTrue(DynamicObject.deserialize(\"#T1{}\", Object.class) instanceof T1);\r\nassertTrue(DynamicObject.deserialize(\"#T2{}\", Object.class) instanceof T2);\r\n```\r\n\r\n### Extending Edn\r\n\r\nIn addition to Edn's built-in data types (sets, maps, vectors, `#inst`, `#uuid`, and so forth), DynamicObject offers full support for reader tags, Edn's extension mechanism. This makes it possible to include any Java value class in a `DynamicObject` without compromising serializability or requiring any modifications to the class. This is done through the `EdnTranslator` mechanism.\r\n\r\nFor instance, consider the following Edn data:\r\n\r\n```clojure\r\n{:name \"Mike Jones\",\r\n :phone #phonenumber \"(330) 281-8004\"}\r\n```\r\n\r\nThe `:name` field is an ordinary string, but the `:phone` field is tagged. When we deserialize this data, we don't want the phone number to be returned as a string, but rather as an instance of the following type:\r\n\r\n```java\r\npublic class PhoneNumber {\r\n  public final String areaCode;\r\n  public final String firstThree;\r\n  public final String lastFour;\r\n\r\n  // constructor, etc omitted\r\n}\r\n```\r\n\r\nTo do this, we'll define a class that translates this type to and from Edn:\r\n\r\n```java\r\npublic class PhoneNumberTranslator implements EdnTranslator<PhoneNumber> {\r\n  // Translate the tagged Edn data (in this case, a String) to our actual type.\r\n  public PhoneNumber read(Object obj) {\r\n    String str = (String) obj;\r\n    Pattern pattern = Pattern.compile(\"\\\\((\\\\d+)\\\\) (\\\\d+)-(\\\\d+)\");\r\n    Matcher matcher = pattern.matcher(str);\r\n    if (!matcher.matches())\r\n      throw new IllegalArgumentException(\"Malformed phone number: \" + str);\r\n    return new PhoneNumber(matcher.group(1), matcher.group(2), matcher.group(3));\r\n  }\r\n\r\n  // Return an Edn string representing the serialized phone number.\r\n  public void write(PhoneNumber phoneNumber) {\r\n    return String.format(\"\\\"(%s) %s-%s\\\"\",\r\n      phoneNumber.areaCode, phoneNumber.firstThree, phoneNumber.lastFour);\r\n  }\r\n\r\n  // Return the reader tag associated with this type.\r\n  public String getTag() {\r\n    return \"phonenumber\";\r\n  }\r\n}\r\n```\r\n\r\nFinally, we'll register this translator with DynamicObject:\r\n\r\n```java\r\nDynamicObject.registerType(PhoneNumber.class, new PhoneNumberTranslator());\r\n```\r\n\r\nThe `PhoneNumber` type is now fully interoperable with DynamicObject and Edn serialization. It can even be deserialized Ã  la carte:\r\n\r\n```java\r\nPhoneNumber actual = DynamicObject.deserialize(\"#phonenumber \\\"(330) 281-8004\\\"\", PhoneNumber.class);\r\nPhoneNumber expected = new PhoneNumber(\"330\", \"281\", \"8004\");\r\nassertEquals(expected, actual);\r\n```\r\n\r\n### Fressian serialization\r\n\r\nDynamicObject exposes Fressian's `FressianReader` and `FressianWriter` classes directly, in order to maximize flexibility. Instances of these classes are obtained by calling `createFressianReader` and `createFressianWriter`. These methods return readers and writers that understand:\r\n\r\n* all of the basic Fressian and data.fressian types\r\n* extension types that have been registered with DynamicObject\r\n* DynamicObject types that have a registered reader tag\r\n\r\nConvenience methods are also offered: `toFressianByteArray` takes an Object and returns a byte array, and `fromFressianByteArray` does the reverse.\r\n\r\nConceptually, extending Fressian is no different from extending Edn. The `PhoneNumber` class from above can be translated to and from Fressian like so:\r\n\r\n```java\r\npublic class PhoneNumberEncoder implements ReadHandler, WriteHandler {\r\n  @Override\r\n  public Object read(Reader r, Object tag, int componentCount) throws IOException {\r\n    String areaCode = (String) r.readObject();\r\n    String firstThree = (String) r.readObject();\r\n    String lastFour = (String) r.readObject();\r\n    return new PhoneNumber(areaCode, firstThree, lastFour);\r\n  }\r\n\r\n  @Override\r\n  public void write(Writer w, Object instance) throws IOException {\r\n    PhoneNumber phoneNumber = (PhoneNumber) instance;\r\n    // In addition to the reader tag, we must specify how many fields we will write.\r\n    w.writeTag(\"phonenumber\", 3);\r\n    w.writeObject(phoneNumber.areaCode);\r\n    w.writeObject(phoneNumber.firstThree);\r\n    w.writeObject(phoneNumber.lastFour);\r\n  }\r\n}\r\n```\r\n\r\nAs with Edn, this type must be registered with DynamicObject:\r\n\r\n```java\r\nPhoneNumberEncoder encoder = new PhoneNumberEncoder();\r\nDynamicObject.registerType(PhoneNumber.class, \"phonenumber\", encoder, encoder);\r\n\r\nPhoneNumber before = new PhoneNumber(\"123\", \"456\", \"7890\");\r\nbyte[] byteArray = DynamicObject.toFressianByteArray(PhoneNumber);\r\nPhoneNumber after = DynamicObject.fromFressianByteArray(byteArray);\r\nassertEquals(before, after);\r\n```\r\n\r\n### Schema Validation\r\n\r\nTraditional object mappers pretend to transparently put static types on the wire. As a consequence, it is difficult to get them to accept any data that does not exactly match the object type they are expecting to see. For instance, if they see an unknown field, they will likely discard it, or they might just throw an exception, causing deserialization to fail altogether. The problem is usually not obvious right away; generally, it only becomes obvious once the software is running in production and needs to accommodate changes.\r\n\r\nDynamicObject takes a completely different approach in which deserialization and validation are decoupled into two separate phases, each of which is independently available to the user. Any well-formed Edn data can be deserialized into any given `DynamicObject` type, and all of the data that was present on the wire will be preserved in its entirety in memory. Validation of the data can then proceed as a separate step. (Note that validation can also be performed on objects that were created using builders, rather than deserialized. This can be a way to ensure that none of the `@Required` fields were overlooked during construction.)\r\n\r\nValidation checks that all `@Required` fields are present (they must not be null), and that all of the types are correct. Successful validation is a guarantee that any getter method can be invoked without resulting in a `ClassCastException`. For example, consider the following type:\r\n\r\n```java\r\ninterface Validated extends DynamicObject<Validated> {\r\n  @Required int x();\r\n  @Required int y();\r\n  String str();\r\n}\r\n```\r\n\r\nAfter deserializing instances of this type, we can use validation to ensure that they are correct. The `validate()` method will throw an exception if an instance doesn't validate. The exception message will give a detailed description of what went wrong:\r\n\r\n```java\r\nDynamicObject.deserialize(\"{}\", Validated.class).validate();\r\n//  Exception in thread \"main\" java.lang.IllegalStateException: The following @Required fields were missing: x, y\r\n\r\nDynamicObject.deserialize(\"{:x 1, :y 2, :str 3}\", Validated.class).validate();\r\n//  Exception in thread \"main\" java.lang.IllegalStateException: The following fields had the wrong type:\r\n//    str (expected String, got Long)\r\n\r\nDynamicObject.deserialize(\"{:x 1, :y 2, :str \\\"hello\\\"}\", Validated.class).validate();\r\n//  Success!\r\n```\r\n\r\nIt is possible to add custom validation logic to a type by implementing `validate()` as a custom method. For example:\r\n\r\n```java\r\ninterface Custom extends DynamicObject<Custom> {\r\n  @Required int oddsOnly();\r\n\r\n  @Override\r\n  default Custom validate() {\r\n    if (oddsOnly() % 2 == 0)\r\n      throw new IllegalStateException(\"Odd number expected\");\r\n    return this;\r\n  }\r\n}\r\n```\r\n\r\nThis validation logic will be run in addition to the standard validation checks:\r\n\r\n```java\r\nDynamicObject.deserialize(\"{:oddsOnly 4}\", Custom.class).validate();\r\n//  Exception in thread \"main\" java.lang.IllegalStateException: Odd number expected\r\n\r\nDynamicObject.deserialize(\"{:oddsOnly nil}\", Custom.class).validate();\r\n//  Exception in thread \"main\" java.lang.IllegalStateException: The following @Required fields were missing: oddsOnly\r\n\r\nDynamicObject.deserialize(\"{:oddsOnly 5}\", Custom.class).validate();\r\n//  Success!\r\n```\r\n\r\n### Persistent Modification\r\n\r\nDynamicObject makes it easy to leverage Clojure's immutable persistent data structures, which use structural sharing to enable cheap copying and \"modification.\" A DynamicObject can declare builder methods, which are backed by [`assoc`](http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/assoc). These methods perform a functional update of the data structure, returning an updated instance and leaving the current instance unchanged. For example:\r\n\r\n```java\r\ninterface Buildable extends DynamicObject<Buildable> {\r\n  @Key(\":hello\") String getHello();\r\n  @Key(\":hello\") Buildable withHello(String hello);\r\n}\r\n\r\n@Test\r\npublic void invokeBuilderMethod() {\r\n  Buildable hw = DynamicObject.newInstance(Buildable.class).withHello(\"world\");\r\n  assertEquals(\"{:hello \\\"world\\\"}\", DynamicObject.serialize(hw)); // This is the original value\r\n\r\n  Buildable hk = hw.withHello(\"kitty\"); // Build a new value from the old one\r\n  assertEquals(\"{:hello \\\"kitty\\\"}\", DynamicObject.serialize(hk));\r\n  assertEquals(\"{:hello \\\"world\\\"}\", DynamicObject.serialize(hw)); // The original value is unchanged\r\n}\r\n\r\n```\r\n\r\n### Metadata\r\n\r\nDynamicObject allows direct access to Clojure's metadata facilities with the `@Meta` annotation. This allows information to be annotated in arbitrary ways without this information being part of the data itself. For example, if you're using DynamicObject to communicate across processes using a distributed queue like [SQS](http://aws.amazon.com/sqs/), metadata is a great place to stash information about the messages themselves, such as the [message receipt handle](http://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/ImportantIdentifiers.html):\r\n\r\n```java\r\ninterface WorkerJob extends DynamicObject<WorkerJob> {\r\n  UUID jobId();\r\n  String inputLocation();\r\n  // and so forth\r\n  @Meta long messageAgeInSeconds(); // Use this for visibility purposes (e.g. are we falling behind?)\r\n  @Meta String messageReceiptHandle(); // Use this later to delete the message once the job is done\r\n\r\n  // The metadata fields can be set using builder methods:\r\n  WorkerJob messageAgeInSeconds(long seconds);\r\n  WorkerJob messageReceiptHandle(String handle);\r\n  // Note that no redundant @Meta annotation is required on builders\r\n}\r\n```\r\n\r\nRemember that metadata is never serialized, and is ignored for purposes of equality.\r\n\r\n### User-defined Methods\r\n\r\nThanks to Java 8's [default methods](http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html), it is straightforward to declare custom methods on a `DynamicObject`, even though all `DynamicObject` types are interfaces. For example, we could extend the above `Album` example with an `AlbumCollection` type:\r\n\r\n```java\r\npublic interface AlbumCollection extends DynamicObject<AlbumCollection> {\r\n  Set<Album> albums();\r\n\r\n  default int totalTracksInCollection() {\r\n    return albums().stream()\r\n                   .mapToInt(Album::getTracks)\r\n                   .sum();\r\n  }\r\n}\r\n```\r\n\r\n### Custom Keys\r\n\r\nDynamicObject does not have an elaborate system of conventions to map Java method names to Clojure map keys. By default, the name of the getter method is exactly the name of the keyword. `str()` maps to `:str`, and `myString()` maps to `:myString`, not `:my-string`. This default can be overridden with the `@Key` annotation. Suppose we want access to the following data:\r\n\r\n```clojure\r\n{:camelCase 1,\r\n :kebab-case 2,\r\n \"quoted string\" 3}\r\n```\r\n\r\nThe corresponding DynamicObject getters for each field look like this:\r\n\r\n```java\r\nlong camelCase(); // corresponds to the :camelCase field\r\n@Key(\":kebab-case\") long kebabCase(); // corresponds to the :kebab-case field, as opposed to the default :kebabCase\r\n@Key(\"quoted string\") long quotedString(); // corresponds to the \"quoted string\" field\r\n```\r\n\r\nNote the convention: an initial colon yields a Clojure keyword, and anything else yields a string.\r\n\r\nCustom keys have a second purpose: they decouple getters and setters. Without custom keys, the getter method for a given field must have the same name as the builder method for the same field. But if getters and builders both have `@Key` annotations, the methods can take on arbitrary names:\r\n\r\n```java\r\npublic interface MyType extends DynamicObject<MyType> {\r\n  @Key(\":flubber\")    String getFlubber();     // Pretty standard for field access in Java...\r\n  @Key(\":is-flubbed\") boolean isFlubbed();     // ...except for booleans, which generally use \"is\" and not \"get\"\r\n\r\n  @Key(\":flubber\") MyType setFlubber(String flubber);   // You can prefix these with \"set\" if you want...\r\n  @Key(\":flubber\") MyType withFlubber(String flubber);  // ...but \"with\" makes more sense for persistent updates\r\n}\r\n```\r\n\r\n### Clojure Interop\r\n\r\nIn addition to providing a sane alternative to POJOs, DynamicObject implements the map abstractions of both Java and Clojure. This allows the same values to be sent back and forth between Java and Clojure code without wrapping, unwrapping, conversion, or reflection. Java and Clojure code can both idiomatically inspect DynamicObject values and build new ones.\r\n\r\nAs an example, we'll use the RecursionTest's definition of a DynamicObject-based linked list:\r\n\r\n```java\r\npublic interface LinkedList extends DynamicObject<LinkedList> {\r\n  long value();\r\n  LinkedList next();\r\n\r\n  LinkedList value(long value);\r\n  LinkedList next(LinkedList linkedList);\r\n}\r\n```\r\n\r\nThe following REPL session shows the use of this type from Clojure (various imports omitted):\r\n\r\n```clojure\r\n; We'll start by creating a three-node linked list. First, let's register a reader tag:\r\n(DynamicObject/registerTag RecursionTest$LinkedList \"LL\")\r\n\r\n; Now we'll deserialize the tail node from Edn:\r\n(def tail (DynamicObject/deserialize \"#LL{:value 3, :next nil}\" RecursionTest$LinkedList))\r\n=> #'user/tail\r\n\r\n; We'll build the middle node by using standard Clojure functions:\r\n(def middle (-> tail empty (assoc :value 2) (assoc :next tail)))\r\n=> #'user/middle\r\n\r\n; Finally, we'll construct the head node using DynamicObject's builder methods:\r\n(def head (-> middle (.value 1) (.next middle)))\r\n=> #'user/head\r\n\r\n; Let's print the result (note the reader tags):\r\nhead\r\n=> #LL{:next #LL{:next #LL{:value 3, :next nil}, :value 2}, :value 1}\r\n\r\n; Let's navigate around a bit, first in a Clojure style:\r\n(get-in head [:next :next :value])\r\n=> 3\r\n\r\n; Let's try the equivalent Java style as well:\r\n(-> head .next .next .value)\r\n=> 3\r\n\r\n; We can use the DynamicObject instance as a function:\r\n(tail :value)\r\n=> 3\r\n\r\n; Let's modify a deeply nested value:\r\n(assoc-in head [:next :next :value] 19)\r\n=> #LL{:next #LL{:next #LL{:value 19, :next nil}, :value 2}, :value 1}\r\n\r\n; DynamicObject validation can be used from Clojure for runtime type checking:\r\n(.validate (assoc head :next 4))\r\nIllegalStateException The following fields had the wrong type:\r\n  next (expected LinkedList, got Long)\r\n  com.github.rschmitt.dynamicobject.internal.Validation.validateInstance (Validation.java:33)\r\n\r\n; What about pretty printing? Let's make a value that wraps:\r\n(def long-list (-> head (assoc :some-long-key :some-long-value :another-long-key :another-long-value)))\r\n(pprint long-list)\r\n#LL{:another-long-key :another-long-value,\r\n    :some-long-key :some-long-value,\r\n    :next #LL{:next #LL{:value 3, :next nil}, :value 2},\r\n    :value 1}\r\n\r\n; Just for grins, let's round-trip the output:\r\n(DynamicObject/deserialize (with-out-str (pprint long-list)) RecursionTest$LinkedList)\r\n=> #LL{:another-long-key :another-long-value, :some-long-key :some-long-value, :next #LL{:next #LL{:value 3, :next nil}, :value 2}, :value 1}\r\n(= *1 long-list)\r\n=> true\r\n\r\n; Let's play with Fressian:\r\n(def head-bytes (DynamicObject/toFressianByteArray head))\r\n=> #'user/head-bytes\r\n(vec head-bytes)\r\n=> [-17 -36 76 76 1 -64 -24 -54 -9 -51 -34 110 101 120 116 -96 -64 -24 -54 -9 -128 -96 -64 -24 -54 -9 -51 -33 118 97 108 117 101 3 -54 -9 -128 -9 -54 -9 -127 2 -54 -9 -127 1]\r\n(DynamicObject/fromFressianByteArray head-bytes)\r\n=> #LL{:next #LL{:next #LL{:value 3, :next nil}, :value 2}, :value 1}\r\n```\r\n\r\n## Guidelines\r\n\r\n* Always register a reader tag for any `DynamicObject` that will be serialized. This reader tag should be namespaced with some appropriate prefix (e.g. a Java package name), as all unprefixed reader tags are reserved for future use by the Edn specification.\r\n* Always include a version number in data that will be serialized. This way, older consumers can check the version number and decline any messages that they are not capable of handling properly.\r\n* Annotate required fields with `@Required` and call `validate()` to ensure that all required fields are present.\r\n* Use [`java.util.Optional`](http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html) in your schema with fields that are not `@Required`. Internally, DynamicObject unwraps `Optional` values; they do not affect serialization, and they provide additional null safety by making it obvious (at the actual call site, not just the schema) that a given field might not be present.\r\n  * Correspondingly, unboxed primitive fields should always be marked `@Required`, as they cannot be effectively checked for null. Optional fields should always use the boxed type.\r\n* It is okay to submit a mutable collection such as a `java.util.ArrayList` to a `DynamicObject` builder method. Internally, all collection elements are copied to an immutable Clojure collection.\r\n  * Similarly, all collection getter methods return an immutable persistent collection. Attempts to mutate these collections will result in an `UnsupportedOperationException`.\r\n* Do not abuse user-defined methods. A [pure function](http://en.wikipedia.org/wiki/Pure_function) is often a good candidate for a custom method; anything else should be viewed with suspicion.\r\n\r\n## Constraints and Limitations\r\n\r\n* Since unboxed primitives cannot be null, any attempt to dereference an unboxed primitive field whose underlying value is null or missing will result in a `NullPointerException`.\r\n* DynamicObject has no concept of inheritance. There is no provision for deriving one DynamicObject type from another.\r\n* DynamicObject's builders and getters copy and transform collections--for instance, a getter returning a `List<Integer>` must copy from a `List<Long>`. This can have performance impact.\r\n* There is no way to teach DynamicObject to make defensive copies of mutable types in getters and builders.\r\n* Java arrays are not currently supported.\r\n* Fressian does not support Clojure sets, vectors, or lists. The Fressian reader will return Java's mutable collection types instead.\r\n\r\n## Developing\r\n\r\nDynamicObject should work out-of-the-box with [IntelliJ 14.1](http://www.jetbrains.com/idea/download/). The Community Edition is sufficient. You'll need [JDK8](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) installed and configured as an SDK within IntelliJ. You will also need the Maven plugin for dependency resolution; this is generally included by default.\r\n\r\nYou can also run the build from the command line using `mvn package`. To just run the unit tests, use `mvn test`.\r\n\r\n## Influences and Similar Ideas\r\n\r\n* [Lombok](http://www.projectlombok.org/) is a boilerplate elimination tool for Java. It offers the excellent [`@Value`](http://projectlombok.org/features/Value.html) annotation, which helps to take the pain out of Java data modeling. Unfortunately, Lombok by itself does little to solve the problem of serialization/deserialization, and its implementation does horrible violence to the internals of the compiler.\r\n* [Prismatic Schema](https://github.com/Prismatic/schema) is a Clojure library that offers declarative data validation and description in terms of \"schemas.\"\r\n* [core.typed](https://github.com/clojure/core.typed) is a pluggable type system for Clojure. Its concept of [heterogeneous maps](https://github.com/clojure/core.typed/wiki/Types#heterogeneous-maps) helped to clarify how Clojure's extremely general map type could be used effectively in a statically typed language like Java.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}